/*
 * Change Logs:
 * Date           Author       Notes
 * 2021-12-06     derekduke   The first version
 */

#ifndef __MICROINFER_H_
#define __MICROINFER_H_
#include "stdint.h"
#include "stdio.h"
#include "stdlib.h"
#include "string.h"

#include "microinfer_port.h"

//#include "layers/microinfer_input.h"

#define MICROINFER_ALIGN    (sizeof(char*))

typedef enum
{
	NN_SUCCESS = 0,			/**< No error */
	NN_ARGUMENT_ERROR = -1, /**< One or more arguments are incorrect */
	NN_LENGTH_ERROR = -2,   /**< Length of data buffer is incorrect */
	NN_SIZE_MISMATCH = -3,  /**< Size of matrices is not compatible with the operation. */
	NN_NANINF = -4,			/**< Not-a-number (NaN) or infinity is generated */
	NN_SINGULAR = -5,		/**< Generated by matrix inversion if the input matrix is singular and cannot be inverted. */
	NN_TEST_FAILURE = -6,   /**< Test Failed  */
	NN_NO_MEMORY = -7,
	NN_MORE_TODO = -8
} microinfer_status_t;

typedef enum
{
	MICROINFER_INPUT

}microinfer_layer_type_t;

typedef struct _microinfer_layer_io_t microinfer_layer_io_t;
typedef struct _microinfer_layer_hook_t microinfer_layer_hook_t;
typedef struct _microinfer_layer_t microinfer_layer_t;

typedef struct _microinfer_tensor_t microinfer_tensor_t;

struct _microinfer_layer_hook_t
{
	microinfer_layer_io_t *io;	    // hooked io
	microinfer_layer_hook_t *next;  // next hook include secondary hooked layer
};

struct _microinfer_layer_io_t
{
	microinfer_layer_hook_t hook;		  // for example: (layer->out)--hook--(layer->in)
	microinfer_tensor_t* tensor;
    microinfer_layer_io_t *next; 		  // point to auxilary I/O (multiple I/O layer)
	microinfer_layer_t *owner;		      // which layer owns this io.
};

struct _microinfer_layer_t
{
	microinfer_status_t (*run)(microinfer_layer_t* layer);
	microinfer_status_t (*build)(microinfer_layer_t* layer);
	microinfer_status_t (*free)(microinfer_layer_t* layer);
	microinfer_layer_type_t type;
	microinfer_layer_io_t *in;	  // IO buff, last*layer, states
	microinfer_layer_io_t *out;   // IO buff, next*layer, states
};

struct _microinfer_model_t
{
    microinfer_layer_t* head;
    microinfer_layer_t* tail;
    microinfer_layer_t* (*hook)(microinfer_layer_t* curr , microinfer_layer_t* pre);  
};
typedef struct _microinfer_model_t microinfer_model_t;

#define microinfer_shape_t uint16_t
#define microinfer_shape_data_t uint16_t

typedef struct _microinfer_3d_shape_t
{
	microinfer_shape_t h, w, c;
}microinfer_3d_shape_t;

struct _microinfer_tensor_t
{
	void* p_data;			// value
	microinfer_shape_data_t *dim; // dimension of this tensor
	//nnom_qformat_param_t *q_dec;	// number of decimal bit for Q format (scale)
	//nnom_qformat_param_t *q_offset;	// offset for each channel
	//nnom_qtype_t qtype;			// the quantisation type	
	uint8_t num_dim;			// the number of dimension
	uint8_t bitwidth;			// the data bit width, only support 8bit now
};

microinfer_model_t* model_init(microinfer_model_t* model);

#endif