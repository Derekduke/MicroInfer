/*
 * Change Logs:
 * Date           Author       Notes
 * 2021-12-06     derekduke   The first version
 */

#ifndef __MICROINFER_H_
#define __MICROINFER_H_
#include "stdint.h"
#include "stdio.h"
#include "stdlib.h"
#include "string.h"

#include "microinfer_port.h"

#define MICROINFER_ALIGN    (sizeof(char*))
#define q7_t 	int8_t
#define q15_t 	int16_t
#define q31_t 	int32_t
#define q63_t 	int64_t

#define MICROINFER_TENSOR_BUF_NULL     (0)	// This buffer is not in used
#define MICROINFER_TENSOR_BUF_TEMP     (1)  // The memory in IO is temporary occupided, can be reused by other layer once the computation is done.
#define MICROINFER_TENSOR_BUF_RESERVED (2)  // the mem is reserve for this layer only (not to be reused by other layer.

#define MICROINFER_MAJORVERSION     0             
#define MICROINFER_SUBVERSION       0              
#define MICROINFER_REVISION         1 

#define MICROINFER_BUF_EMPTY   (0)
#define MICROINFER_BUF_FILLED  (1)

#define microinfer_qformat_param_t int32_t // this should match the backend, need a better way to do it. 
#define microinfer_shape_t uint16_t
#define microinfer_shape_data_t uint16_t

#define DEFUALT_LAYER_NAMES \
	{                       \
		"Unknown",          \
			"Base",			\
			"Input",        \
			"Output",       \
			"Conv2D",       \
			"DW_Conv2D",    \
			"Conv2DTrsp",    \
			"BatchNorm",	\
			"Dense",        \
			"ZeroPad",	    \
			"Cropping",     \
			"RNN",          \
			"Activation",   \
			"ReLU",         \
			"Leaky_ReLU",	\
			"Adv_ReLU",	    \
			"Sigmoid",      \
			"Tanh",         \
			"Softmax",      \
			"MaxPool",      \
			"GL_MaxPool",	\
			"AvgPool",      \
			"GL_AvgPool",	\
			"SumPool",		\
			"GL_SumPool",	\
			"UpSample",		\
			"Flatten",      \
			"Lambda",       \
			"Concat",       \
			"Add",          \
			"Sub",          \
			"Mult",         \
	}
extern const char default_layer_names[][12];

typedef enum
{
	NN_SUCCESS = 0,			/**< No error */
	NN_ARGUMENT_ERROR = -1, /**< One or more arguments are incorrect */
	NN_LENGTH_ERROR = -2,   /**< Length of data buffer is incorrect */
	NN_SIZE_MISMATCH = -3,  /**< Size of matrices is not compatible with the operation. */
	NN_NANINF = -4,			/**< Not-a-number (NaN) or infinity is generated */
	NN_SINGULAR = -5,		/**< Generated by matrix inversion if the input matrix is singular and cannot be inverted. */
	NN_TEST_FAILURE = -6,   /**< Test Failed  */
	NN_NO_MEMORY = -7,
	NN_MORE_TODO = -8
} microinfer_status_t;

typedef enum
{
	MICROINFER_INVALID = 0,
	MICROINFER_BASE,
	MICROINFER_INPUT,
	MICROINFER_OUTPUT,
	MICROINFER_CONV_2D,
	MICROINFER_DW_CONV_2D,
	MICROINFER_CONV2D_TRANS,
	MICROINFER_BATCHNORM,
	MICROINFER_DENSE,
	MICROINFER_ZERO_PADDING,
	MICROINFER_CROPPING,
	MICROINFER_RNN,
	MICROINFER_ACTIVATION,
	MICROINFER_RELU,
	MICROINFER_LEAKY_RELU,
	MICROINFER_ADV_RELU,
	MICROINFER_SIGMOID,
	MICROINFER_TANH,
	MICROINFER_SOFTMAX,
	MICROINFER_MAXPOOL,
	MICROINFER_GLOBAL_MAXPOOL,
	MICROINFER_AVGPOOL,
	MICROINFER_GLOBAL_AVGPOOL,
	MICROINFER_SUMPOOL,
	MICROINFER_GLOBAL_SUMPOOL,
	MICROINFER_UPSAMPLE,
	MICROINFER_FLATTEN,
	MICROINFER_LAMBDA,
	MICROINFER_CONCAT,
	MICROINFER_ADD,
	MICROINFER_SUB,
	MICROINFER_MULT,
	MICROINFER_TYPE_MAX

}microinfer_layer_type_t;

typedef enum
{
	MICROINFER_QTYPE_PER_TENSOR = 0,
	MICROINFER_QTYPE_PER_AXIS = 1
} microinfer_qtype_t;

typedef enum
{
    ACT_UNKNOWN = 0,
	ACT_RELU,
	ACT_LEAKY_RELU,
	ACT_ADV_RELU,
	ACT_TANH,
	ACT_SIGMOID,
    ACT_HARD_TANH,
    ACT_HARD_SIGMOID
} microinfer_activation_type_t;

typedef enum
{
	PADDING_VALID = 0,
	PADDING_SAME
} microinfer_padding_t;

typedef struct _microinfer_weights
{
	const void *p_value;
	microinfer_qformat_param_t shift;
} microinfer_weight_t;

typedef struct _nnom_bias
{
	const void *p_value;
	microinfer_qformat_param_t shift;
} microinfer_bias_t;

#define ACTIVATION_NAMES \
	{                    \
        "Unknown",          \
		"ReLU",          \
		"LkyReLU",		 \
		"AdvReLU",		\
		"TanH",      \
		"Sigmoid",   \
        "HrdTanH",      \
		"HrdSigd",   \
	}
extern const char default_activation_names[][8];

typedef struct _microinfer_layer_io_t microinfer_layer_io_t;
typedef struct _microinfer_layer_hook_t microinfer_layer_hook_t;
typedef struct _microinfer_layer_t microinfer_layer_t;
typedef struct _microinfer_tensor_t microinfer_tensor_t;
typedef struct _microinfer_model_t microinfer_model_t;
typedef struct _microinfer_mem_block_t microinfer_mem_block_t;
typedef struct _microinfer_buf microinfer_buf_t;
typedef struct _microinfer_activation_t microinfer_activation_t;

struct _microinfer_layer_hook_t
{
	microinfer_layer_io_t *io;	    // hooked io
	microinfer_layer_hook_t *next;  // next hook include secondary hooked layer
};

struct _microinfer_layer_io_t
{
	microinfer_layer_hook_t hook;		  // for example: (layer->out)--hook--(layer->in)
	microinfer_tensor_t* tensor;
	microinfer_mem_block_t* mem;
    microinfer_layer_io_t *next; 		  // point to auxilary I/O (multiple I/O layer)
	microinfer_layer_t *owner;		      // which layer owns this io.
	uint8_t type;
};

struct _microinfer_layer_t
{
	microinfer_status_t (*run)(microinfer_layer_t* layer);
	microinfer_status_t (*build)(microinfer_layer_t* layer);
	microinfer_status_t (*free)(microinfer_layer_t* layer);
	microinfer_buf_t* comp;
	microinfer_activation_t* actail;
	microinfer_layer_type_t type;
	microinfer_layer_io_t *in;	  // IO buff, last*layer, states
	microinfer_layer_io_t *out;   // IO buff, next*layer, states
};

struct _microinfer_activation_t
{
	microinfer_status_t (*run)(struct _microinfer_activation_t *act);
	microinfer_tensor_t *tensor;
	microinfer_activation_type_t type;
};

struct _microinfer_mem_block_t
{
	void *blk;		// data block location
	uint32_t size;	// the maximum size for this block
	uint8_t owners; // how many layers own this block
	uint8_t state;  // empty? filled? for static nn, currently only used in compiling
};

struct _microinfer_buf
{
	microinfer_mem_block_t *mem;
	uint32_t size;
	uint8_t type;
};

struct _microinfer_model_t
{
    microinfer_layer_t* head;
    microinfer_layer_t* tail;
    microinfer_layer_t* (*hook)(microinfer_layer_t* curr , microinfer_layer_t* pre);
	microinfer_layer_t *(*active)(microinfer_activation_t *act, microinfer_layer_t *target_layer);	
	microinfer_mem_block_t blocks[MICROINFER_BLOCK_NUM];
};

typedef struct _microinfer_3d_shape_t
{
	microinfer_shape_t h, w, c;
}microinfer_3d_shape_t;

struct _microinfer_tensor_t
{
	void* p_data;					// value
	microinfer_shape_data_t *dim; 	// dimension of this tensor
	microinfer_qformat_param_t *q_dec;	// number of decimal bit for Q format (scale)
	microinfer_qformat_param_t *q_offset;	// offset for each channel
	microinfer_qtype_t qtype;			// the quantisation type	
	uint8_t num_dim;			// the number of dimension
	uint8_t bitwidth;			// the data bit width, only support 8bit now
};

microinfer_model_t* model_create(microinfer_model_t* model);
microinfer_status_t model_compile(microinfer_model_t* m , microinfer_layer_t* input , microinfer_layer_t* output);
microinfer_status_t model_run(microinfer_model_t *m);
microinfer_status_t microinfer_predict(microinfer_model_t *m, uint32_t *label, float *prob);

uint32_t microinfer_alignto(uint32_t value , uint32_t alignment);
void microinfer_set_buf(void* buf , uint32_t size);
void* microinfer_malloc(uint32_t size);
void* microinfer_free(void* p);
void* microinfer_mem(uint32_t size);
microinfer_status_t compile_layers(microinfer_layer_t* first, microinfer_layer_t *curr, microinfer_mem_block_t *block_pool, uint32_t *layer_count);


#endif